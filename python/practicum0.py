# -*- coding: utf-8 -*-
"""Practicum0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vz-s2K_eDkhj44cDaV5lEyUF4nWz5fHG

# Practicum 0
Woo, a notebooks environment! Stuff's crazy. 

**All of the sections except for the bottom two (*Challenge 1* and *Challenge 2*) were prep work.**

# Variables
"""

age = 230
price = 20.33
fname = "Tasty"
new_patient = False
print(f"{fname} is {age} years old, costs {price}, and True/False is a new patient: {new_patient}")

"""# Input"""

movie = input("What is your favorite movie? ")
print(f"You have terrible tast if {movie} is your favorite movie. /s")

"""# Type Conversion"""

dob = int(input("When were you born? "))
age = 2023-dob
if age < 42:
  print("You're yonger than Doctah Mahtin! Congrats!")
else:
  print("you basically have one foot in the grave, I'm sorry")

"""# Strings
is your password guessable?
"""

password = "doctah mahtin is a cool guy"
guess = input("Guess a substring of the password: ")
print(f"Did you guess an actual substring of the password? {guess in password}")

"""# Arithmetic Operators"""

print(12321312124 % 67)
# spooky scary skeletons

"""# Operator Precendance"""

one = 6+10*40
two = (6+10)*40
print(one)
print(two)

"""# Comparison Operators"""

x = 3 == 2
y = 3 > 2
z = 3 < 2
print(x)
print(y)
print(z)

"""# Logical Operators"""

dr_martin_age = 42
young = 30
ancient = 70
print(dr_martin_age > young)
print(dr_martin_age < ancient)
print(dr_martin_age > young and dr_martin_age < ancient)

"""# If statements"""

number = int(input("How many movies have you seen in the last 365 days?"))
if number < 10:
  print("Those are some rookie numbers.")
elif number < 30:
  print("That's a decent amount.")
elif number < 80:
  print("That's quite a lot.")
else:
  print("Jesus, how many gigabytes is your Plex server?")

"""# Exercise"""

weight = float(input("Weight: "))
unit = input("(K)g or (L)b: ").upper()
if unit == "K":
  print(f"{weight*2.20462} lbs")
elif unit == "L":
  print(f"{weight*0.453592} kg")
else:
  print("Invalid unit.")

"""# While Loops"""

dr_martin_cool = False
while not dr_martin_cool:
  print("ha", end="")

"""# Lists"""

list_of_cool_people = ['Patrick Marshall', 'Adam', 'Charles']
print(f"{list_of_cool_people=} Strange, I don't see Dr. Martin on there :thinking_face:")

"""# List Methods"""

numbers = [1, 2, 3, 4, 5, 6, 7, 8]
numbers.insert(2, 43)
print(2 in numbers)

"""# For loops"""

epic_gamers = ['Patrick', "Charles", "Adam"]
for people in epic_gamers:
  print(people)

"""# range() function"""

my_list = range(10,20,1)
print(my_list)
for num in my_list:
  print(num)

"""# Tuples"""

one = (1,2)
two = (2,3)
three = one + two
print(three)

"""# Challenge 1
The algorithim I used I had to re-google because I kind of just do this in my head at this point: I got the algorithm from [here.](https://www.cuemath.com/numbers/decimal-to-binary/)

**Summary:**

1. Create an empty string to store the result: `r = ''`
1. Divide by 2: `divmod(val,2)`
1. Store the quotient and remainder: `q, r = divmod(val,2)`
1. Add the remainder to the *beginning* of our result string: `result = r + result`
1. Repeat until quotient = 0: `while q != 0:`
1. Return result string: `return result`
"""

def decimal_to_binary(value: int) -> str:
  """Take base 10 int, return binary representation string."""
  quotient = value 
  # Create an empty string to store the result
  result = ""
  while quotient != 0:
    # Call the divide function by passing the dividend and divisor
    quotient, r = divmod(quotient, 2)
    # Add to the result string
    result = str(r) + result
  return result

"""**Testing my code:**

1. Generate test values: `vals = [1, 2, 3, 4, 5]`
1. Print each test value as stored and after calling **decimal_to_binary()**: `print(x + decimal_to_binary(x))`


"""

test_vals = [1, 2, 3, 4, 5, 22, 48, 100]
for vals in test_vals:
  # for each value, print its original base 10 form and its binary form
  print(f"Base 10: {vals} Base 2: {decimal_to_binary(vals)}")

"""# Challenge 2
Using a list comprehesion to transform all data in one line. List comprehensions are one-liners to generate lists from other lists. I used [this great resource](https://www.w3schools.com/python/python_lists_comprehension.asp) to remember the exact syntax (because as simple as it is, I always forget it!) It's basically:
`new_list = [x for x in old_list]`

Adam showed me how to use this import to get around the Python 3.8 type hinting weirdness. It is: `from typing import List`. Basically, I'm importing the type so the interpreter knows what I'm trying to do. Note how in my function declaration, my type hints for **List** are capitalized. This is compared to all-lowercase **list** as it works in Python 3.9 onward.
"""

from typing import List

def transform_data(func: callable, data: List[float]) -> List[float]:
  """Perform the func on the whole list and return it."""
  return [func(x) for x in data]

"""One-liner to square a float."""

def square(x: float) -> float:
  """Square x and return it."""
  return x*x

"""One-liner to square root a float."""

import math

def square_root(x: float) -> float:
  """Take the square root of x and return it."""
  return math.sqrt(x)

"""**Testing my code:**

1. Generating test values: `vals = [1, 2, 3]`
1. Running **square()** and **suqare_root()** on each value to test these functions:
```
for x in vals:
   print(x + square(x) + square_root(x))
```
1. Calling **transform_data()** on the list and passing both **square()** and **square_root()** to verify the outputs match
```
print(vals)
print(transform_data(square, vals))
print(transform_data(square_root, vals))
```
"""

test_vals = [2, 4, 6, 8, 10]
print("Testing the functions individually:")
for vals in test_vals:
  print(f"Original: {vals} Squared: {square(vals)} Square-rooted: {square_root(vals)}")

print("\nTesting the transform_data function:")
print(f"Original: {test_vals}")
print(f"Square: {transform_data(square, test_vals)}")
print(f"Square root: {transform_data(square_root, test_vals)}")

"""Below is the code I used to check what version of python this is running - because 3.9 is where they added the ability to specify list contents in type hinting. I found this command at this [absolutely awful website.](https://blog.finxter.com/how-to-check-python-version-in-colab/)"""

!python --version